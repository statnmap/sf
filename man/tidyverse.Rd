% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tidyverse.R, R/join.R
\name{tidyverse}
\alias{tidyverse}
\alias{filter.sf}
\alias{tidyverse}
\alias{arrange.sf}
\alias{tidyverse}
\alias{group_by.sf}
\alias{tidyverse}
\alias{ungroup.sf}
\alias{tidyverse}
\alias{mutate.sf}
\alias{tidyverse}
\alias{transmute.sf}
\alias{tidyverse}
\alias{select.sf}
\alias{tidyverse}
\alias{rename.sf}
\alias{tidyverse}
\alias{slice.sf}
\alias{tidyverse}
\alias{summarise.sf}
\alias{summarise}
\alias{tidyverse}
\alias{distinct.sf}
\alias{tidyverse}
\alias{gather.sf}
\alias{tidyverse}
\alias{spread.sf}
\alias{tidyverse}
\alias{sample_n.sf}
\alias{tidyverse}
\alias{sample_frac.sf}
\alias{tidyverse}
\alias{nest.sf}
\alias{tidyverse}
\alias{separate.sf}
\alias{tidyverse}
\alias{unite.sf}
\alias{tidyverse}
\alias{unnest.sf}
\alias{tidyverse}
\alias{inner_join.sf}
\alias{tidyverse}
\alias{left_join.sf}
\alias{tidyverse}
\alias{right_join.sf}
\alias{tidyverse}
\alias{full_join.sf}
\alias{tidyverse}
\alias{semi_join.sf}
\alias{tidyverse}
\alias{anti_join.sf}
\title{Tidyverse methods for sf objects}
\usage{
filter.sf(.data, ..., .dots)

arrange.sf(.data, ..., .dots)

group_by.sf(.data, ..., add = FALSE)

ungroup.sf(x, ...)

mutate.sf(.data, ..., .dots)

transmute.sf(.data, ..., .dots)

select.sf(.data, ...)

rename.sf(.data, ...)

slice.sf(.data, ..., .dots)

summarise.sf(.data, ..., .dots, do_union = TRUE)

distinct.sf(.data, ..., .keep_all = FALSE)

gather.sf(data, key, value, ..., na.rm = FALSE, convert = FALSE,
  factor_key = FALSE)

spread.sf(data, key, value, fill = NA, convert = FALSE, drop = TRUE,
  sep = NULL)

sample_n.sf(tbl, size, replace = FALSE, weight = NULL,
  .env = parent.frame())

sample_frac.sf(tbl, size = 1, replace = FALSE, weight = NULL,
  .env = parent.frame())

nest.sf(data, ..., .key = "data")

separate.sf(data, col, into, sep = "[^[:alnum:]]+", remove = TRUE,
  convert = FALSE, extra = "warn", fill = "warn", ...)

unite.sf(data, col, ..., sep = "_", remove = TRUE)

unnest.sf(data, ..., .preserve = NULL)

inner_join.sf(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

left_join.sf(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

right_join.sf(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

full_join.sf(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

semi_join.sf(x, y, by = NULL, copy = FALSE, ...)

anti_join.sf(x, y, by = NULL, copy = FALSE, ...)
}
\arguments{
\item{.data}{data object of class \link{sf}}

\item{...}{other arguments}

\item{.dots}{see corresponding function in package \code{dplyr}}

\item{add}{see corresponding function in dplyr}

\item{x}{tbls to join}

\item{do_union}{logical; in case \code{summary} does not create a geometry column, should geometries be created by unioning using \link{st_union}, or simply by combining using \link{st_combine}? Using \link{st_union} resolves internal boundaries, but in case of unioning points, this will likely change the order of the points; see Details.}

\item{.keep_all}{see corresponding function in dplyr}

\item{data}{see original function docs}

\item{key}{see original function docs}

\item{value}{see original function docs}

\item{na.rm}{see original function docs}

\item{convert}{see original function docs}

\item{factor_key}{see original function docs}

\item{fill}{see original function docs}

\item{drop}{see original function docs}

\item{sep}{see original function docs}

\item{tbl}{see original function docs}

\item{size}{see original function docs}

\item{replace}{see original function docs}

\item{weight}{see original function docs}

\item{.env}{see original function docs}

\item{.key}{see \link[tidyr]{nest}}

\item{col}{see \link[tidyr]{separate}}

\item{into}{see \link[tidyr]{separate}}

\item{remove}{see \link[tidyr]{separate}}

\item{extra}{see \link[tidyr]{separate}}

\item{.preserve}{see \link[tidyr]{unnest}}

\item{y}{tbls to join}

\item{by}{a character vector of variables to join by.  If \code{NULL}, the
default, \code{*_join()} will do a natural join, using all variables with
common names across the two tables. A message lists the variables so
that you can check they're right (to suppress the message, simply
explicitly list the variables that you want to join).

To join by different variables on x and y use a named vector.
For example, \code{by = c("a" = "b")} will match \code{x.a} to
\code{y.b}.}

\item{copy}{If \code{x} and \code{y} are not from the same data source,
and \code{copy} is \code{TRUE}, then \code{y} will be copied into the
same src as \code{x}.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.}

\item{suffix}{If there are non-joined duplicate variables in \code{x} and
\code{y}, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.}
}
\value{
an object of class \link{sf}
}
\description{
Tidyverse methods for sf objects. Geometries are sticky, use \link{as.data.frame} to let \code{dplyr}'s own methods drop them.
}
\details{
\code{select} keeps the geometry regardless whether it is selected or not; to deselect it, first pipe through \code{as.data.frame} to let dplyr's own \code{select} drop it.

In case one or more of the arguments (expressions) in the \code{summarise} call creates a geometry list-column, the first of these will be the (active) geometry of the returned object. If this is not the case, a geometry column is created, depending on the value of \code{do_union}.

In case \code{do_union} is \code{FALSE}, \code{summarise} will simply combine geometries using \link{c.sfg}. When polygons sharing a boundary are combined, this leads to geometries that are invalid; see for instance \url{https://github.com/r-spatial/sf/issues/681}.

\code{distinct.sf} gives distinct records for which all attributes and geometries are distinct; \link{st_equals} is used to find out which geometries are distinct.

\code{nest.sf} assumes that a simple feature geometry list-column was among the columns that were nested.
}
\examples{
library(dplyr)
nc = st_read(system.file("shape/nc.shp", package="sf"))
nc \%>\% filter(AREA > .1) \%>\% plot()
# plot 10 smallest counties in grey:
st_geometry(nc) \%>\% plot()
nc \%>\% select(AREA) \%>\% arrange(AREA) \%>\% slice(1:10) \%>\% plot(add = TRUE, col = 'grey')
title("the ten counties with smallest area")
nc$area_cl = cut(nc$AREA, c(0, .1, .12, .15, .25))
nc \%>\% group_by(area_cl) \%>\% class()
nc2 <- nc \%>\% mutate(area10 = AREA/10)
nc \%>\% transmute(AREA = AREA/10, geometry = geometry) \%>\% class()
nc \%>\% transmute(AREA = AREA/10) \%>\% class()
nc \%>\% select(SID74, SID79) \%>\% names()
nc \%>\% select(SID74, SID79, geometry) \%>\% names()
nc \%>\% select(SID74, SID79) \%>\% class()
nc \%>\% select(SID74, SID79, geometry) \%>\% class()
nc2 <- nc \%>\% rename(area = AREA)
nc \%>\% slice(1:2)
nc$area_cl = cut(nc$AREA, c(0, .1, .12, .15, .25))
nc.g <- nc \%>\% group_by(area_cl)
nc.g \%>\% summarise(mean(AREA))
nc.g \%>\% summarise(mean(AREA)) \%>\% plot(col = grey(3:6 / 7))
nc \%>\% as.data.frame \%>\% summarise(mean(AREA))
nc[c(1:100, 1:10), ] \%>\% distinct() \%>\% nrow()
library(tidyr)
nc \%>\% select(SID74, SID79) \%>\% gather("VAR", "SID", -geometry) \%>\% summary()
library(tidyr)
nc$row = 1:100 # needed for spread to work
nc \%>\% select(SID74, SID79, geometry, row) \%>\%
	gather("VAR", "SID", -geometry, -row) \%>\%
	spread(VAR, SID) \%>\% head()
storms.sf = st_as_sf(storms, coords = c("long", "lat"), crs = 4326)
x <- storms.sf \%>\% group_by(name, year) \%>\% nest
trs = lapply(x$data, function(tr) st_cast(st_combine(tr), "LINESTRING")[[1]]) \%>\% st_sfc(crs = 4326)
trs.sf = st_sf(x[,1:2], trs)
plot(trs.sf["year"], axes = TRUE)
}
